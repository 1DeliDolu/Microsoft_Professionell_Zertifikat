## ğŸ—ºï¸ Proje Planlama ve TasarÄ±m

BaÅŸarÄ±lÄ± yazÄ±lÄ±m geliÅŸtirmenin anahtarÄ±, dikkatli planlama ve tasarÄ±mdÄ±r. SaÄŸlam bir proje planÄ±yla, kodunuzun dÃ¼zenli, verimli ve karmaÅŸÄ±k gÃ¶revler Ã¼zerinde Ã§alÄ±ÅŸmaya hazÄ±r olmasÄ±nÄ± saÄŸlayabilirsiniz. Bu videoda, kapsamlÄ± bir kod projesini planlayÄ±p tasarlayacaÄŸÄ±z.

Bir kodlama projesini planlamak ve tasarlamak; proje gereksinimlerini tanÄ±mlamayÄ±, hedefleri belirlemeyi ve temel kodlama kavramlarÄ±nÄ± iÃ§eren bir tasarÄ±m taslaÄŸÄ± oluÅŸturmayÄ± kapsar. Bu adÄ±mlarÄ± bir Ã¶rnek Ã¼zerinden inceleyelim.

Ä°ÅŸ arkadaÅŸlarÄ±nÄ±zÄ±n gÃ¶revlerini takip etmelerine yardÄ±mcÄ± olacak bir gÃ¶rev yÃ¶netimi uygulamasÄ± yapmak istiyorsunuz. Ä°lk olarak proje gereksinimlerini tanÄ±mlayarak baÅŸlayÄ±n.

---

## ğŸ“‹ Proje Gereksinimlerini TanÄ±mlama

Bir projenin gereksinimleri; baÅŸarÄ±sÄ±nÄ± saÄŸlamak ve zamanÄ±nda tamamlamak iÃ§in karÅŸÄ±lanmasÄ± gereken Ã§Ä±ktÄ±lar ile tamamlanmasÄ± gereken gÃ¶revlerdir. Proje gereksinimleri iki ana kategoriye ayrÄ±lÄ±r: *functional* ve  *non-functional* .

---

## âš™ï¸ Functional Requirements

Functional requirements, uygulamanÄ±n ne yapmasÄ± gerektiÄŸini, uygulamayÄ± Ã§alÄ±ÅŸÄ±r kÄ±lan temel iÅŸlevleri tanÄ±mlar. Åu sorulara yanÄ±t verir: uygulama neyi baÅŸarmalÄ±?

GÃ¶rev yÃ¶netimi uygulamamÄ±z iÃ§in functional requirements oldukÃ§a nettir. Uygulama, kullanÄ±cÄ±larÄ±n gÃ¶rev eklemesine, gÃ¶revleri gÃ¶zden geÃ§irmesine ve gÃ¶revleri tamamlamasÄ±na izin vermelidir.

Bunlar uygulamayÄ± kullanÄ±ÅŸlÄ± kÄ±lan temel eylemlerdir.

---

## ğŸ§© Non-Functional Requirements

Non-functional requirements, uygulamanÄ±n nasÄ±l performans gÃ¶stermesi gerektiÄŸini kapsar. Bunlar kullanÄ±labilirlik, performans ve gÃ¼venlik gibi konulardÄ±r.

UygulamanÄ±n sadece iÅŸlevsel deÄŸil, aynÄ± zamanda gÃ¼venilir ve kullanmasÄ± keyifli olmasÄ±nÄ± saÄŸlarlar.

GÃ¶rev uygulamasÄ± iÃ§in non-functional requirements, kullanÄ±labilirlik ve performans Ã¼zerine odaklanÄ±r.

UygulamanÄ±n sezgisel bir arayÃ¼zÃ¼ olmalÄ± ve kullanÄ±cÄ±larÄ±n gÃ¶rev oluÅŸturmasÄ±nÄ±, dÃ¼zenlemesini ve silmesini en fazla Ã¼Ã§ seÃ§imle yapabilmesine imkÃ¢n vermelidir.

Uygulama ayrÄ±ca gÃ¶rev listesini iki saniye iÃ§inde yÃ¼kleyebilmeli ve performans dÃ¼ÅŸÃ¼ÅŸÃ¼ olmadan 10.000 gÃ¶reve kadar iÅŸleyebilmelidir.

---

## ğŸ¯ Proje Hedeflerini Belirleme

Gereksinimlerimiz belirlendikten sonra, bir sonraki adÄ±m net proje hedefleri koymaktÄ±r.

Hedefler, bir kiÅŸinin veya sÃ¼recin belirli bir zaman dilimi iÃ§inde ulaÅŸmayÄ± amaÃ§ladÄ±ÄŸÄ± somut sonuÃ§lardÄ±r.

UygulamamÄ±z iÃ§in hedefler ÅŸunlarÄ± iÃ§erebilir:

* ÃœÃ§ ay iÃ§inde gÃ¶rev ekleme, gÃ¶zden geÃ§irme ve tamamlama iÃ§in kod tabanÄ±nÄ± oluÅŸturmak
* DÃ¶rt ay iÃ§inde gÃ¶rev depolama iÃ§in veri entegrasyonunu uygulamak
* YayÄ±n Ã¶ncesinde test ve debuggingâ€™i tamamlamak, kritik bugâ€™larÄ±n yÃ¼zde 95â€™ini Ã§Ã¶zmek

Bu hedefler Ã¶lÃ§Ã¼lebilirdir. UygulamayÄ± geliÅŸtirirken, hedefleri karÅŸÄ±layÄ±p karÅŸÄ±lamadÄ±ÄŸÄ±nÄ± her zaman kontrol edebiliriz.

Net hedefler yÃ¶n saÄŸlar ve proje takvimini korumaya yardÄ±mcÄ± olur. SÃ¼rece dahil olan herkesin tam olarak neyin baÅŸarÄ±lmasÄ± gerektiÄŸini bilmesini saÄŸlar.

Ä°yi tanÄ±mlanmÄ±ÅŸ hedeflerle, zaman, emek ve bÃ¼tÃ§e gibi kaynaklarÄ± daha etkili ÅŸekilde daÄŸÄ±tabiliriz; bu da tÃ¼m sÃ¼reci daha akÄ±cÄ± hÃ¢le getirir.

---

## ğŸ§± TasarÄ±m TaslaÄŸÄ± OluÅŸturma

Åimdi tasarÄ±m taslaÄŸÄ± oluÅŸturmaya geÃ§elim.

Bu, gereksinimlerimizi ve hedeflerimizi uygulamanÄ±n nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±na dair bir plana dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ÄŸÃ¼mÃ¼z aÅŸamadÄ±r.

Bir tasarÄ±m taslaÄŸÄ±, uygulamayÄ± inÅŸa etmek iÃ§in adÄ±m adÄ±m bir rehber gÃ¶revi gÃ¶rÃ¼r.

GÃ¶rev yÃ¶netimi uygulamamÄ±zÄ± tasarlamak iÃ§in projeyi daha kÃ¼Ã§Ã¼k ve yÃ¶netilebilir modÃ¼llere bÃ¶leceÄŸiz ve bunlarÄ± uygulamak iÃ§in kullanacaÄŸÄ±mÄ±z kod bileÅŸenlerini planlayacaÄŸÄ±z.

GÃ¶rev uygulamamÄ±z iÃ§in:

* GÃ¶revleri gÃ¶rÃ¼ntÃ¼leme modÃ¼lÃ¼ne ihtiyacÄ±mÄ±z var; bu modÃ¼l kullanÄ±cÄ±larÄ±n gÃ¶rev listesini istedikleri zaman gÃ¶zden geÃ§irebileceÄŸi basit bir arayÃ¼z saÄŸlayacak.
* GÃ¶rev ekleme modÃ¼lÃ¼ne ihtiyacÄ±mÄ±z var; bu modÃ¼l yeni gÃ¶revleri girmek iÃ§in doÄŸrudan bir yÃ¶ntem sunacak.
* GÃ¶revleri tamamlandÄ± olarak iÅŸaretleme modÃ¼lÃ¼ne ihtiyacÄ±mÄ±z var; bu modÃ¼l seÃ§ilebilen checkbox arayÃ¼z Ã¶ÄŸeleri saÄŸlayacak.

Bu taslak, uygulama yapÄ±sÄ±nÄ± incelememize yardÄ±mcÄ± olur ve herhangi bir temel Ã¶zelliÄŸi kaÃ§Ä±rmadÄ±ÄŸÄ±mÄ±zdan emin olmamÄ±zÄ± saÄŸlar.

---

## ğŸ§  ModÃ¼lleri Uygulamak Ä°Ã§in Kod BileÅŸenlerini Planlama

Åimdi, modÃ¼lleri uygulamak iÃ§in kullanacaÄŸÄ±mÄ±z kod bileÅŸenlerini planlayalÄ±m.

Bu modÃ¼lleri uygulamak iÃ§in  *variables* ,  *methods* , *if/else statements* ve *loops* kullanmamÄ±z gerekir.

---

## ğŸ§¾ Variables ile Veri Saklama

Variables bilgi sakladÄ±ÄŸÄ± iÃ§in, proje boyunca nerelerde veri tutmamÄ±z gerektiÄŸini Ã¶nceden taslaklandÄ±rmalÄ±yÄ±z.

Ã–rneÄŸin yapÄ±lacaklar listesi uygulamamÄ±zda, her gÃ¶rev iÃ§in bir `string` deÄŸiÅŸkenine ihtiyacÄ±mÄ±z vardÄ±r.

KullanÄ±cÄ± her gÃ¶rev eklediÄŸinde, gÃ¶rev bir diziye veya deÄŸiÅŸkenlerden oluÅŸan bir listeye kaydedilir.

---

## ğŸ› ï¸ Methods ile Ä°ÅŸlevleri Gruplama

Sonra methods tasarlamalÄ±yÄ±z. Bunlar, ilgili gÃ¶revleri yeniden kullanÄ±labilir tek bir kod birimi altÄ±nda toplamamÄ±zÄ± saÄŸlar.

YapÄ±lacaklar listesi uygulamasÄ±nda, her modÃ¼l iÃ§in bir metot olmalÄ±dÄ±r; `view task`, `add task` ve `mark task complete` dahil.

---

## ğŸ”€ If/Else ile Karar NoktalarÄ±nÄ± YÃ¶netme

ArdÄ±ndan, uygulamada kararlarÄ±n nerede verileceÄŸini planlarÄ±z.

KoÅŸullara baÄŸlÄ± farklÄ± senaryolarÄ± yÃ¶netmek iÃ§in if/else statements kullanacaÄŸÄ±z.

Ã–rneÄŸin, kullanÄ±cÄ±nÄ±n bir gÃ¶rev girip girmediÄŸini kontrol etmek iÃ§in bir if/else statement kullanmayÄ± planlarÄ±z.

EÄŸer giriÅŸ alanÄ± boÅŸsa, kullanÄ±cÄ±dan gÃ¶rev girmesini isteyen bir mesaj gÃ¶stereceÄŸiz.

Aksi halde, gÃ¶revi listeye eklemek iÃ§in bir mesaj gÃ¶stereceÄŸiz.

---

## ğŸ” Loops ile Tekrarlayan Ä°ÅŸlemler

Son olarak, modÃ¼llerimizin herhangi birinde koÅŸullara baÄŸlÄ± olarak kodun tekrar etmesi gerekip gerekmediÄŸini belirlemeliyiz.

TekrarlamanÄ±n gerekli olduÄŸu yerleri tespit eder ve bu durumlarÄ± yÃ¶netmek iÃ§in loops kullanmayÄ± planlarÄ±z.

YapÄ±lacaklar listesi uygulamasÄ±nda, kullanÄ±cÄ± uygulamayÄ± her aÃ§tÄ±ÄŸÄ±nda eklenmiÅŸ tÃ¼m gÃ¶revleri ekranda gÃ¶stermek iÃ§in bir loop kullanacaÄŸÄ±z.

---

## âœ… KapanÄ±ÅŸ

Bu videoda, kapsamlÄ± bir kod projesini planlamayÄ± ve tasarlamayÄ± Ã¶ÄŸrendiniz.

GÃ¶rev yÃ¶netimi uygulamamÄ±zÄ±n her yÃ¶nÃ¼nÃ¼; gereksinimleri ve hedefleri tanÄ±mlamaktan bir tasarÄ±m oluÅŸturmaya kadar dikkatle planlayÄ±p tasarlayarak, uygulamanÄ±n kullanÄ±cÄ± dostu, verimli ve geliÅŸtirmeye hazÄ±r olmasÄ±nÄ± saÄŸlarÄ±z.



## ğŸ—ï¸ Proje UygulamasÄ±

GÃ¶rev yÃ¶netimi uygulamasÄ±nÄ± planladÄ±ÄŸÄ±mÄ±za gÃ¶re, artÄ±k C# ve Visual Studio Code kullanarak inÅŸa etme zamanÄ±. Bu videoda, Ã¶ÄŸrenilmiÅŸ kodlama kavramlarÄ±nÄ± kullanarak planlanan projeyi uygulayacaÄŸÄ±z. Kodu satÄ±r satÄ±r ele alÄ±p nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± aÃ§Ä±klayacaÄŸÄ±m; bÃ¶ylece her adÄ±mÄ±n arkasÄ±ndaki mantÄ±ÄŸÄ± anlayabilirsiniz.

HatÄ±rladÄ±ÄŸÄ±nÄ±z gibi, uygulama kullanÄ±cÄ±larÄ±n gÃ¶rev eklemesine, gÃ¶revleri tamamlandÄ± olarak iÅŸaretlemesine ve gÃ¶revleri gÃ¶rÃ¼ntÃ¼lemesine izin verecek. Hadi oluÅŸturmaya baÅŸlayalÄ±m.

---

## ğŸ§© TaskManager SÄ±nÄ±fÄ±nÄ± TanÄ±mlama

Ã–nce `TaskManager` adÄ±nda bir sÄ±nÄ±f tanÄ±mlayacaÄŸÄ±m. GÃ¶revleri yÃ¶netmekle ilgili tÃ¼m mantÄ±ÄŸÄ± burada saklayacaÄŸÄ±m.

Åimdi iki adet `static` liste tanÄ±mladÄ±m: biri gÃ¶rev aÃ§Ä±klamalarÄ±nÄ± saklamak iÃ§in `tasks`, diÄŸeri her gÃ¶revin tamamlanÄ±p tamamlanmadÄ±ÄŸÄ±nÄ± izlemek iÃ§in `taskStatus`.

`List<string>`, gÃ¶rev aÃ§Ä±klamalarÄ±nÄ±n metin deÄŸerlerini tutar. `List<bool>` ise Boolean deÄŸerler tutar; burada `false` bekleyen gÃ¶revleri, `true` ise tamamlanmÄ±ÅŸ gÃ¶revleri temsil eder.

---

## ğŸ“‹ MenÃ¼ ile KullanÄ±cÄ± EtkileÅŸimini YÃ¶netme

Bir sonraki adÄ±m, kullanÄ±cÄ± etkileÅŸimini bir menÃ¼ aracÄ±lÄ±ÄŸÄ±yla yÃ¶netmektir. KullanÄ±cÄ±dan sÃ¼rekli bir eylem seÃ§mesini isteyen bir `Main` metodu oluÅŸturacaÄŸÄ±m.

`Main` metodu uygulamanÄ±n giriÅŸ noktasÄ±dÄ±r. Bu durumda `static` bir modifiye ediciye sahiptir; yani sÄ±nÄ±fÄ±n kendisine aittir, sÄ±nÄ±fÄ±n Ã¶rneklerine deÄŸil.

Metot `void` dÃ¶ndÃ¼rÃ¼r; yani herhangi bir deÄŸer dÃ¶ndÃ¼rmez.

Parametre olarak bir `string` dizisi alÄ±r; bu, program baÅŸlarken kullanÄ±cÄ±larÄ±n argÃ¼man geÃ§ebilmesine imkÃ¢n tanÄ±r.

Metodun iÃ§inde, kullanÄ±cÄ± Ã§Ä±kmayÄ± seÃ§ene kadar menÃ¼yÃ¼ sÃ¼rekli gÃ¶stermek iÃ§in bir `while` dÃ¶ngÃ¼sÃ¼ oluÅŸtururum.

MenÃ¼ dÃ¶rt seÃ§enek sunar: gÃ¶rev ekle, gÃ¶revi tamamlandÄ± olarak iÅŸaretle, gÃ¶revleri gÃ¶rÃ¼ntÃ¼le ve Ã§Ä±kÄ±ÅŸ.

Bu dÃ¶rt seÃ§enek iÃ§in `Console.WriteLine` fonksiyonunu kullanÄ±rÄ±m.

KullanÄ±cÄ±nÄ±n girdisini almak iÃ§in `Console.ReadLine` fonksiyonunu kullanÄ±r ve girdiyi `choice` adlÄ± bir `string` deÄŸiÅŸkende saklarÄ±m.

SeÃ§imlere gÃ¶re iÅŸlem yapmak iÃ§in bir `switch` ifadesi kullanÄ±rÄ±m.

`switch` ifadesi, kullanÄ±cÄ±nÄ±n seÃ§imine gÃ¶re dÃ¶rt `case` ve bir `default case` iÃ§erir.

* Case 1â€™de, gÃ¶rev eklemek iÃ§in ilgili metot olan `AddTask` Ã§aÄŸrÄ±lÄ±r.
* Case 2â€™de, gÃ¶revi tamamlandÄ± olarak iÅŸaretlemek iÃ§in `CompleteTask` metodu Ã§aÄŸrÄ±lÄ±r.
* Case 3â€™te, gÃ¶rev listesini gÃ¶stermek iÃ§in `ViewTasks` metodu Ã§aÄŸrÄ±lÄ±r.
* Case 4, programdan Ã§Ä±kmak iÃ§in `return` kullanÄ±r.
* `default case`, giriÅŸ geÃ§ersizse kullanÄ±lÄ±r; bir hata mesajÄ± yazdÄ±rÄ±r ve menÃ¼yÃ¼ tekrar gÃ¶sterir.

---

## â• GÃ¶rev Ekleme Ä°ÅŸlevini Uygulama

Åimdi gÃ¶rev ekleme iÅŸlevini uygulayalÄ±m.

Bir `AddTask` metodu oluÅŸtururum ve Ã¶nce kullanÄ±cÄ±ya bir gÃ¶rev aÃ§Ä±klamasÄ± girmesini `Console.WriteLine` ile sorarÄ±m.

AÃ§Ä±klama, `Console.ReadLine` ile kullanÄ±cÄ±dan alÄ±nÄ±r ve `task` adlÄ± `string` tÃ¼rÃ¼nde bir deÄŸiÅŸkende saklanÄ±r.

Bu gÃ¶revi `tasks.Add` kullanarak `tasks` listesine eklerim; metoda `task` parametresini geÃ§iririm.

AyrÄ±ca yeni gÃ¶rev baÅŸlangÄ±Ã§ta tamamlanmadÄ±ÄŸÄ± iÃ§in `taskStatus` listesine `false` eklerim.

Son olarak, gÃ¶revin baÅŸarÄ±yla eklendiÄŸini kullanÄ±cÄ±ya bildiren bir onay mesajÄ± yazdÄ±rÄ±rÄ±m.

---

## âœ… GÃ¶revleri TamamlandÄ± Olarak Ä°ÅŸaretleme

ArtÄ±k gÃ¶rev ekleyebildiÄŸimize gÃ¶re, gÃ¶revleri tamamlandÄ± olarak iÅŸaretleyelim.

Bunu yapmak iÃ§in bir `CompleteTask` metodu oluÅŸtururum.

Ã–nce `if-else` ifadesiyle `tasks` listesinde gÃ¶rev olup olmadÄ±ÄŸÄ±nÄ± kontrol ederim. Bunun iÃ§in listenin `Count` Ã¶zelliÄŸini kullanÄ±rÄ±m.

`tasks.Count` deÄŸerini `0` ile `==` kullanarak karÅŸÄ±laÅŸtÄ±rÄ±rÄ±m.

Liste boÅŸsa, â€œtamamlanacak gÃ¶rev yokâ€ mesajÄ± yazdÄ±rÄ±rÄ±m ve `return` ile metottan Ã§Ä±karÄ±m.

Sonra kullanÄ±cÄ±dan tamamlandÄ± olarak iÅŸaretlemek istediÄŸi gÃ¶revin numarasÄ±nÄ± girmesini isterim.

Girdi, kullanÄ±cÄ± bir ÅŸey yazÄ±p Enterâ€™a basana kadar bekleyen `Console.ReadLine` ile alÄ±nÄ±r.

Girdi alÄ±ndÄ±ktan sonra, `int.TryParse` ile bunu tamsayÄ±ya Ã§evirmeyi denerim. Bu, girdinin geÃ§erli bir sayÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.

ArdÄ±ndan gÃ¶rev numarasÄ±nÄ±n geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol ederim: sÄ±fÄ±rdan bÃ¼yÃ¼k olmalÄ± ve listedeki toplam gÃ¶rev sayÄ±sÄ±ndan kÃ¼Ã§Ã¼k veya eÅŸit olmalÄ±dÄ±r.

Bu kontrol, `taskNumber > 0` ve `taskNumber <= tasks.Count` koÅŸullarÄ±yla yapÄ±lÄ±r.

EÄŸer sayÄ± bu aralÄ±kta ise, ilgili gÃ¶revi tamamlandÄ± olarak iÅŸaretlerim.

Bunun iÃ§in `taskStatus` listesindeki `taskNumber - 1` konumundaki deÄŸeri `true` yaparÄ±m. Bu, gÃ¶revin tamamlandÄ±ÄŸÄ±nÄ± gÃ¶sterir.

SonrasÄ±nda, gÃ¶rev aÃ§Ä±klamasÄ±nÄ± da iÃ§eren bir onay mesajÄ± gÃ¶steririm; yani gÃ¶rev numarasÄ±nÄ±n tamamlandÄ± olarak iÅŸaretlendiÄŸini belirtirim.

Girdi geÃ§ersizse, yani sayÄ± deÄŸilse veya gÃ¶rev aralÄ±ÄŸÄ±nÄ±n dÄ±ÅŸÄ±ndaysa, â€œgeÃ§ersiz gÃ¶rev numarasÄ±â€ mesajÄ± yazdÄ±rÄ±rÄ±m.

Bu, kullanÄ±cÄ±nÄ±n geÃ§erli bir gÃ¶rev numarasÄ± girmesi gerektiÄŸini anlamasÄ±nÄ± saÄŸlar.

---

## ğŸ“‹ GÃ¶revleri GÃ¶rÃ¼ntÃ¼leme

Åimdi kullanÄ±cÄ±nÄ±n gÃ¶rev listesini gÃ¶rÃ¼ntÃ¼lemesini saÄŸlayan metoda geÃ§elim.

Bir `ViewTasks` metodu oluÅŸtururum ve Ã¶nce `tasks.Count` kontrolÃ¼yle gÃ¶rÃ¼ntÃ¼lenecek gÃ¶rev olup olmadÄ±ÄŸÄ±na bakarÄ±m.

HiÃ§ gÃ¶rev yoksa, â€œgÃ¶rev yokâ€ mesajÄ± yazdÄ±rÄ±r ve metottan Ã§Ä±karÄ±m.

GÃ¶revler varsa, `for` dÃ¶ngÃ¼sÃ¼ ile `tasks` listesini dolaÅŸÄ±r ve her gÃ¶revi durumuyla birlikte yazdÄ±rÄ±rÄ±m.

DÃ¶ngÃ¼ `0`â€™dan `tasks.Count - 1`â€™e kadar Ã§alÄ±ÅŸÄ±r ve her gÃ¶rev iÃ§in `taskStatus` listesinden durumu alÄ±rÄ±m.

Durum `true` ise `Completed` yazdÄ±rÄ±rÄ±m. Aksi halde `Pending` yazdÄ±rÄ±rÄ±m.

SonrasÄ±nda `Console.WriteLine` ile gÃ¶rev numarasÄ±nÄ±, aÃ§Ä±klamasÄ±nÄ± ve durumunu yazdÄ±rÄ±rÄ±m.

GÃ¶rev numarasÄ± kullanÄ±cÄ± dostu olmasÄ± iÃ§in `i + 1` olarak gÃ¶sterilir.

---

## âœ… SonuÃ§

GÃ¶rev yÃ¶netimi uygulamasÄ±nÄ±n Ã§ekirdek Ã¶zelliklerini uyguladÄ±ktan sonra, gÃ¶rev ekleme, gÃ¶rÃ¼ntÃ¼leme ve tamamlama iÃ§in Ã§alÄ±ÅŸan bir araca sahip oluruz.

Bunun gibi gerÃ§ek dÃ¼nya Ã¶rnekleriyle ne kadar Ã§ok Ã§alÄ±ÅŸÄ±rsanÄ±z, C#â€™Ä± anlamada ve kodlama kavramlarÄ±nÄ± projelerinize uygulamada o kadar iyi olursunuz.
